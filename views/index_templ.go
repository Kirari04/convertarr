// Code generated by templ - DO NOT EDIT.

// templ: version: v0.3.906
package views

//lint:file-ignore SA4006 This context is only used if a nested component is present.

import "github.com/a-h/templ"
import templruntime "github.com/a-h/templ/runtime"

import (
	"encoder/app"
	"encoder/layouts"
	"encoder/t"
	"fmt"
	"time"
)

func Index(Ctx t.TemplCtx, Title string, longStats bool, savedStorage string, encodedFiles string, intervalSeconds int) templ.Component {
	return templruntime.GeneratedTemplate(func(templ_7745c5c3_Input templruntime.GeneratedComponentInput) (templ_7745c5c3_Err error) {
		templ_7745c5c3_W, ctx := templ_7745c5c3_Input.Writer, templ_7745c5c3_Input.Context
		if templ_7745c5c3_CtxErr := ctx.Err(); templ_7745c5c3_CtxErr != nil {
			return templ_7745c5c3_CtxErr
		}
		templ_7745c5c3_Buffer, templ_7745c5c3_IsBuffer := templruntime.GetBuffer(templ_7745c5c3_W)
		if !templ_7745c5c3_IsBuffer {
			defer func() {
				templ_7745c5c3_BufErr := templruntime.ReleaseBuffer(templ_7745c5c3_Buffer)
				if templ_7745c5c3_Err == nil {
					templ_7745c5c3_Err = templ_7745c5c3_BufErr
				}
			}()
		}
		ctx = templ.InitializeContext(ctx)
		templ_7745c5c3_Var1 := templ.GetChildren(ctx)
		if templ_7745c5c3_Var1 == nil {
			templ_7745c5c3_Var1 = templ.NopComponent
		}
		ctx = templ.ClearChildren(ctx)
		templ_7745c5c3_Var2 := templruntime.GeneratedTemplate(func(templ_7745c5c3_Input templruntime.GeneratedComponentInput) (templ_7745c5c3_Err error) {
			templ_7745c5c3_W, ctx := templ_7745c5c3_Input.Writer, templ_7745c5c3_Input.Context
			templ_7745c5c3_Buffer, templ_7745c5c3_IsBuffer := templruntime.GetBuffer(templ_7745c5c3_W)
			if !templ_7745c5c3_IsBuffer {
				defer func() {
					templ_7745c5c3_BufErr := templruntime.ReleaseBuffer(templ_7745c5c3_Buffer)
					if templ_7745c5c3_Err == nil {
						templ_7745c5c3_Err = templ_7745c5c3_BufErr
					}
				}()
			}
			ctx = templ.InitializeContext(ctx)
			templ_7745c5c3_Err = templruntime.WriteString(templ_7745c5c3_Buffer, 1, "<article class=\"message\"><div class=\"message-header\"><p>Dashboard</p>")
			if templ_7745c5c3_Err != nil {
				return templ_7745c5c3_Err
			}
			if longStats {
				templ_7745c5c3_Err = templruntime.WriteString(templ_7745c5c3_Buffer, 2, "<a href=\"/\" class=\"button is-primary\">Show Live Stats</a>")
				if templ_7745c5c3_Err != nil {
					return templ_7745c5c3_Err
				}
			} else {
				templ_7745c5c3_Err = templruntime.WriteString(templ_7745c5c3_Buffer, 3, "<a href=\"/?long=yes\" class=\"button is-primary\">Show Long-Term Stats</a>")
				if templ_7745c5c3_Err != nil {
					return templ_7745c5c3_Err
				}
			}
			templ_7745c5c3_Err = templruntime.WriteString(templ_7745c5c3_Buffer, 4, "</div><div class=\"message-body\"><div class=\"columns is-multiline has-text-centered\"><div class=\"column is-flex\"><article class=\"box\" style=\"width: 100%;\"><p class=\"title\">")
			if templ_7745c5c3_Err != nil {
				return templ_7745c5c3_Err
			}
			var templ_7745c5c3_Var3 string
			templ_7745c5c3_Var3, templ_7745c5c3_Err = templ.JoinStringErrs(fmt.Sprint(len(app.FilesToEncode)))
			if templ_7745c5c3_Err != nil {
				return templ.Error{Err: templ_7745c5c3_Err, FileName: `views/index.templ`, Line: 30, Col: 60}
			}
			_, templ_7745c5c3_Err = templ_7745c5c3_Buffer.WriteString(templ.EscapeString(templ_7745c5c3_Var3))
			if templ_7745c5c3_Err != nil {
				return templ_7745c5c3_Err
			}
			templ_7745c5c3_Err = templruntime.WriteString(templ_7745c5c3_Buffer, 5, "</p><p class=\"subtitle\">Files in Queue</p></article></div><div class=\"column is-flex\"><article class=\"box\" style=\"width: 100%;\"><p class=\"title\">")
			if templ_7745c5c3_Err != nil {
				return templ_7745c5c3_Err
			}
			var templ_7745c5c3_Var4 string
			templ_7745c5c3_Var4, templ_7745c5c3_Err = templ.JoinStringErrs(fmt.Sprint(len(app.PreloadedFiles.Get())))
			if templ_7745c5c3_Err != nil {
				return templ.Error{Err: templ_7745c5c3_Err, FileName: `views/index.templ`, Line: 36, Col: 67}
			}
			_, templ_7745c5c3_Err = templ_7745c5c3_Buffer.WriteString(templ.EscapeString(templ_7745c5c3_Var4))
			if templ_7745c5c3_Err != nil {
				return templ_7745c5c3_Err
			}
			templ_7745c5c3_Err = templruntime.WriteString(templ_7745c5c3_Buffer, 6, "</p><p class=\"subtitle\">Pre-Copied Files</p><p class=\"help\">Files copied locally, ready for encoding.</p></article></div><div class=\"column is-flex\"><article class=\"box\" style=\"width: 100%;\"><p class=\"title\">")
			if templ_7745c5c3_Err != nil {
				return templ_7745c5c3_Err
			}
			var templ_7745c5c3_Var5 string
			templ_7745c5c3_Var5, templ_7745c5c3_Err = templ.JoinStringErrs(fmt.Sprintf("%d", app.LastScanNFiles))
			if templ_7745c5c3_Err != nil {
				return templ.Error{Err: templ_7745c5c3_Err, FileName: `views/index.templ`, Line: 43, Col: 63}
			}
			_, templ_7745c5c3_Err = templ_7745c5c3_Buffer.WriteString(templ.EscapeString(templ_7745c5c3_Var5))
			if templ_7745c5c3_Err != nil {
				return templ_7745c5c3_Err
			}
			templ_7745c5c3_Err = templruntime.WriteString(templ_7745c5c3_Buffer, 7, "</p><p class=\"subtitle\">Files Scanned</p><p class=\"help\">")
			if templ_7745c5c3_Err != nil {
				return templ_7745c5c3_Err
			}
			if app.LastFileScan != nil {
				templ_7745c5c3_Err = templruntime.WriteString(templ_7745c5c3_Buffer, 8, "Last scan ")
				if templ_7745c5c3_Err != nil {
					return templ_7745c5c3_Err
				}
				var templ_7745c5c3_Var6 string
				templ_7745c5c3_Var6, templ_7745c5c3_Err = templ.JoinStringErrs(fmt.Sprintf("%.0fs", time.Since(*app.LastFileScan).Seconds()))
				if templ_7745c5c3_Err != nil {
					return templ.Error{Err: templ_7745c5c3_Err, FileName: `views/index.templ`, Line: 47, Col: 82}
				}
				_, templ_7745c5c3_Err = templ_7745c5c3_Buffer.WriteString(templ.EscapeString(templ_7745c5c3_Var6))
				if templ_7745c5c3_Err != nil {
					return templ_7745c5c3_Err
				}
				templ_7745c5c3_Err = templruntime.WriteString(templ_7745c5c3_Buffer, 9, "s ago. ")
				if templ_7745c5c3_Err != nil {
					return templ_7745c5c3_Err
				}
			} else {
				templ_7745c5c3_Err = templruntime.WriteString(templ_7745c5c3_Buffer, 10, "Never scanned. ")
				if templ_7745c5c3_Err != nil {
					return templ_7745c5c3_Err
				}
			}
			if app.IsFileScanning {
				templ_7745c5c3_Err = templruntime.WriteString(templ_7745c5c3_Buffer, 11, "<span class=\"tag is-info is-light\">Scanning...</span>")
				if templ_7745c5c3_Err != nil {
					return templ_7745c5c3_Err
				}
			}
			templ_7745c5c3_Err = templruntime.WriteString(templ_7745c5c3_Buffer, 12, "</p></article></div><div class=\"column is-flex\"><article class=\"box\" style=\"width: 100%;\"><p class=\"title\">")
			if templ_7745c5c3_Err != nil {
				return templ_7745c5c3_Err
			}
			var templ_7745c5c3_Var7 string
			templ_7745c5c3_Var7, templ_7745c5c3_Err = templ.JoinStringErrs(savedStorage)
			if templ_7745c5c3_Err != nil {
				return templ.Error{Err: templ_7745c5c3_Err, FileName: `views/index.templ`, Line: 59, Col: 38}
			}
			_, templ_7745c5c3_Err = templ_7745c5c3_Buffer.WriteString(templ.EscapeString(templ_7745c5c3_Var7))
			if templ_7745c5c3_Err != nil {
				return templ_7745c5c3_Err
			}
			templ_7745c5c3_Err = templruntime.WriteString(templ_7745c5c3_Buffer, 13, "</p><p class=\"subtitle\">Storage Saved</p></article></div><div class=\"column is-flex\"><article class=\"box\" style=\"width: 100%;\"><p class=\"title\">")
			if templ_7745c5c3_Err != nil {
				return templ_7745c5c3_Err
			}
			var templ_7745c5c3_Var8 string
			templ_7745c5c3_Var8, templ_7745c5c3_Err = templ.JoinStringErrs(encodedFiles)
			if templ_7745c5c3_Err != nil {
				return templ.Error{Err: templ_7745c5c3_Err, FileName: `views/index.templ`, Line: 65, Col: 38}
			}
			_, templ_7745c5c3_Err = templ_7745c5c3_Buffer.WriteString(templ.EscapeString(templ_7745c5c3_Var8))
			if templ_7745c5c3_Err != nil {
				return templ_7745c5c3_Err
			}
			templ_7745c5c3_Err = templruntime.WriteString(templ_7745c5c3_Buffer, 14, "</p><p class=\"subtitle\">Files Encoded</p></article></div></div><div class=\"box\"><h3 class=\"title is-4\">Server Resource Usage</h3>")
			if templ_7745c5c3_Err != nil {
				return templ_7745c5c3_Err
			}
			if longStats {
				templ_7745c5c3_Err = templruntime.WriteString(templ_7745c5c3_Buffer, 15, "<p class=\"subtitle is-6\">Showing long-term stats (average CPU/Mem/Net usage over the last ")
				if templ_7745c5c3_Err != nil {
					return templ_7745c5c3_Err
				}
				var templ_7745c5c3_Var9 string
				templ_7745c5c3_Var9, templ_7745c5c3_Err = templ.JoinStringErrs(fmt.Sprintf("%s", app.ResourcesInterval*time.Duration(app.MaxResourcesHistory)))
				if templ_7745c5c3_Err != nil {
					return templ.Error{Err: templ_7745c5c3_Err, FileName: `views/index.templ`, Line: 75, Col: 153}
				}
				_, templ_7745c5c3_Err = templ_7745c5c3_Buffer.WriteString(templ.EscapeString(templ_7745c5c3_Var9))
				if templ_7745c5c3_Err != nil {
					return templ_7745c5c3_Err
				}
				templ_7745c5c3_Err = templruntime.WriteString(templ_7745c5c3_Buffer, 16, ")</p>")
				if templ_7745c5c3_Err != nil {
					return templ_7745c5c3_Err
				}
			} else {
				templ_7745c5c3_Err = templruntime.WriteString(templ_7745c5c3_Buffer, 17, "<p class=\"subtitle is-6\">Showing live stats (more accurate CPU/Mem/Net usage over the last ")
				if templ_7745c5c3_Err != nil {
					return templ_7745c5c3_Err
				}
				var templ_7745c5c3_Var10 string
				templ_7745c5c3_Var10, templ_7745c5c3_Err = templ.JoinStringErrs(fmt.Sprintf("%s", app.ResourcesInterval*time.Duration(48)))
				if templ_7745c5c3_Err != nil {
					return templ.Error{Err: templ_7745c5c3_Err, FileName: `views/index.templ`, Line: 79, Col: 133}
				}
				_, templ_7745c5c3_Err = templ_7745c5c3_Buffer.WriteString(templ.EscapeString(templ_7745c5c3_Var10))
				if templ_7745c5c3_Err != nil {
					return templ_7745c5c3_Err
				}
				templ_7745c5c3_Err = templruntime.WriteString(templ_7745c5c3_Buffer, 18, ")</p>")
				if templ_7745c5c3_Err != nil {
					return templ_7745c5c3_Err
				}
			}
			templ_7745c5c3_Err = templruntime.WriteString(templ_7745c5c3_Buffer, 19, "<div id=\"resource-chart\"></div></div></div></article>")
			if templ_7745c5c3_Err != nil {
				return templ_7745c5c3_Err
			}
			templ_7745c5c3_Err = chartData(longStats, intervalSeconds).Render(ctx, templ_7745c5c3_Buffer)
			if templ_7745c5c3_Err != nil {
				return templ_7745c5c3_Err
			}
			return nil
		})
		templ_7745c5c3_Err = layouts.Default(Ctx, Title).Render(templ.WithChildren(ctx, templ_7745c5c3_Var2), templ_7745c5c3_Buffer)
		if templ_7745c5c3_Err != nil {
			return templ_7745c5c3_Err
		}
		return nil
	})
}

func chartData(longStats bool, intervalSeconds int) templ.ComponentScript {
	return templ.ComponentScript{
		Name: `__templ_chartData_64fa`,
		Function: `function __templ_chartData_64fa(longStats, intervalSeconds){// --- Helper Functions ---
    function humanFileSize(bytes, si = false, dp = 1) {
        const thresh = si ? 1000 : 1024;
        if (Math.abs(bytes) < thresh) {
            return bytes + ' B';
        }
        const units = si
            ? ['kB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB']
            : ['KiB', 'MiB', 'GiB', 'TiB', 'PiB', 'EiB', 'ZiB', 'YiB'];
        let u = -1;
        const r = 10 ** dp;
        do {
            bytes /= thresh;
            ++u;
        } while (Math.round(Math.abs(bytes) * r) / r >= thresh && u < units.length - 1);
        return bytes.toFixed(dp) + ' ' + units[u];
    }

    /**
     * Generates an array of historical timestamps for the chart's X-axis.
     * @param {number} dataLength - The number of data points.
     * @param {number} interval - The interval between data points in seconds.
     * @returns {number[]} - An array of timestamps in milliseconds.
     */
    const generateTimestamps = (dataLength, interval) => {
        const timestamps = [];
        const now = new Date().getTime();
        for (let i = 0; i < dataLength; i++) {
            // Work backwards from the current time to generate the timeline
            const timestamp = now - ((dataLength - 1 - i) * interval * 1000);
            timestamps.push(timestamp);
        }
        return timestamps;
    };

    // --- Chart State ---
    var chart;
    const dataUrl = ` + "`" + `/stats/data${longStats ? '?long=yes' : ''}` + "`" + `;

    // --- Chart Logic ---
    const updateAndRenderChart = async () => {
        try {
            const response = await fetch(dataUrl);
            if (!response.ok) {
                console.error("Failed to fetch stats data:", response.statusText);
                return;
            }
            const resources = await response.json();
            const dataLength = (resources.Cpu || []).length;
            const timestamps = generateTimestamps(dataLength, intervalSeconds);

            // Pair each data point with its corresponding timestamp, which is required for a datetime axis.
            const seriesData = [
                { name: 'CPU Usage', type: 'area', data: (resources.Cpu || []).map((y, i) => [timestamps[i], y]) },
                { name: 'Memory Usage', type: 'area', data: (resources.Mem || []).map((y, i) => [timestamps[i], y]) },
                { name: 'Network Out', type: 'line', data: (resources.NetOut || []).map((y, i) => [timestamps[i], y]) },
                { name: 'Network In', type: 'line', data: (resources.NetIn || []).map((y, i) => [timestamps[i], y]) }
            ];

            if (!chart) {
                // Initial Render: Create the chart instance if it doesn't exist.
                const options = {
                    series: seriesData,
                    chart: {
                        height: 350,
                        type: 'line',
                        stacked: false, // Allows series to overlap, which is necessary for different scales.
                        zoom: { enabled: true, type: 'x', autoScaleYaxis: true },
                        toolbar: { autoSelected: 'zoom' }
                    },
                    dataLabels: { enabled: false },
                    stroke: { width: [2, 2, 2, 2], curve: 'smooth' },
                    xaxis: {
                        type: 'datetime', // The X-axis now represents time.
                        labels: { datetimeUTC: false } // Display timestamps in the user's local timezone.
                    },
                    // Configure dual Y-axes: one for percentages (CPU/Mem) and one for data rates (Network).
                    yaxis: [
                        { // Primary Y-axis for CPU and Memory (%)
                            seriesName: 'CPU Usage',
                            axisTicks: { show: true },
                            axisBorder: { show: true },
                            title: { text: "CPU / Memory (%)" },
                            min: 0,
                            max: 100,
                            labels: { formatter: (val) => ` + "`" + `${Math.round(val)} %` + "`" + ` }
                        },
                        { seriesName: 'Memory Usage', show: false, min: 0, max: 100 }, // Associates Memory with the first axis
                        { // Secondary Y-axis for Network data (bytes/s), positioned on the right.
                            seriesName: 'Network Out',
                            opposite: true,
                            axisTicks: { show: true },
                            axisBorder: { show: true },
                            title: { text: "Network Usage" },
                            labels: { formatter: (val) => ` + "`" + `${humanFileSize(val, true, 1)}/s` + "`" + ` }
                        },
                        { seriesName: 'Network In', show: false, opposite: true } // Associates Network In with the second axis
                    ],
                    tooltip: {
                        shared: true, // Show a single tooltip for all series at a given time point.
                        intersect: false,
                        x: { format: 'dd MMM yyyy - HH:mm:ss' },
                        // Custom formatter to show the correct unit for each series.
                        y: {
                            formatter: (value, { seriesIndex }) => {
                                if (seriesIndex < 2) { // CPU or Memory
                                    return ` + "`" + `${Math.round(value)} %` + "`" + `;
                                } else { // Network
                                    return ` + "`" + `${humanFileSize(value, true, 2)}/s` + "`" + `;
                                }
                            }
                        }
                    },
                    legend: {
                        position: 'top',
                        horizontalAlign: 'center',
                    }
                };
                chart = new ApexCharts(document.querySelector("#resource-chart"), options);
                chart.render();
            } else {
                // Update existing chart with new data.
                chart.updateSeries(seriesData);
            }

        } catch (error) {
            console.error("Error updating charts:", error);
        }
    };

    // Initial render, then set an interval for periodic updates.
    updateAndRenderChart();
    setInterval(updateAndRenderChart, intervalSeconds * 1000);
}`,
		Call:       templ.SafeScript(`__templ_chartData_64fa`, longStats, intervalSeconds),
		CallInline: templ.SafeScriptInline(`__templ_chartData_64fa`, longStats, intervalSeconds),
	}
}

var _ = templruntime.GeneratedTemplate
